RPC---->线程模型优化
   ---->java5引入锁机制   
        普通锁对象、读写锁对象。
   ---->java5的线程通讯机制
   ---->java5直接提供了线程池
           ---->最早的方式我们是每连接每线程
	   ---->Reactor模式是一个线程可以处理多个连接
	       不需要做并发控制，简化了实现
	       不能充分利用CPU的优势，因为只有一个线程，
	       该线程需要执行所有的操作：accept,read,decode,compute,encode,send
	       实际中decode,encode,compute如果很耗时，则该线程就不能及时
	       响应其它客户的请求
	   ---->Reactor的多线程模式
	        也不可能无线的创建线程
		还是要用线程池控制

           ---->要求大家熟练java5线程池的操作。
	   ---->难点：线程池的大小到底应该设置为多少。
	        公式:线程池中的线程数量=(线程总时间/瓶颈资源时间)*瓶颈资源的线程并行数
		     如果线程数少了，QPS减少，CPU使用率不够
		     如果线程数多了，线程本身的资源消耗，CPU压力变大。QPS也会降低。
		案例:有这样一个模块:
		      线程同步锁(数据库的事务锁) 50ms
		      cpu时间 18ms
		      查询数据库，网络IO 80MS
		      解析结果2ms,如果服务器有两个CPU，这个模块多少线程合适

		      如果CPU是瓶颈资源
		          线程数=(18+2+50+80)/20 * 2 = 15
		      如果数据库的事务锁是瓶颈资源
		          线程数=(50+18+2+80)/50 * 1 = 3;

   ---->CallAble和Future
   ---->java5线程中提供了阻塞队列的操作。
   ---->java5中提供了丰富的同步工具
   ---->java5提供了更丰富的性能更好的集合类
         